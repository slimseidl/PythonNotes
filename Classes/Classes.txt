Classes 

- Multiple variables are frequently closely related and should thus be treated as one variable with multiple parts
- two variables called hours and minutes might be grouped together in a single variable called time
- Class Key Word
    - used to create a user-defined type of object containing groups of related variables and functions
    - class ClassName:
    - defines a new type that can group data and functions to form an object
    - The object maintains a set of attributes that determines the data and behavior of the class

        class Time:
    """ A class that represents a time of day """
        def __init__(self):
            self.hours = 0
            self.minutes = 0
- Instantiation
    calls the class 
    my_variable = class()

    This creates an instance of the class 
    Auto calls the __init__ method 
    init method has a parameter (self)
        references the instance being created 
Methods 
    - functions defined within a class 
    - __init__ is a constructor 
    - creates attributes like self.hours and self.minutes see below 
        - assigns 0 as a default 
    
    class Time:
    """ A class that represents a time of day """
        def __init__(self):
        self.hours = 0
        self.minutes = 0
    - Attributes can be accessed using the attribute reference operator "." (sometimes called the member operator or dot notation) 

    my_time = Time()
        - creates new class instance 
    my_time.hours = 7
    my_time.minutes = 15

Class Example with Methods 

    class Person:
        def __init__(self):
            self.first = ''
            self.last = ''

        def get_full_name(self):
            return f'{self.last}, {self.first}'

Instance Methods 
    - A function defined within a class 
    - must have the self parameter as well         
        class Animal:
            def __init__(self):
                self.sound= ""
            def noise(self, sound):

Class with methods 

    class PersonInfo:
    def __init__(self):
        self.num_kids = 0

    # FIXME: Write inc_num_kids(self)
    def inc_num_kids(self):
        self.num_kids += 1
        return self.num_kids
    

    person1 = PersonInfo()

    print('Kids:', person1.num_kids)
    person1.inc_num_kids()
    print('New baby, kids now:', person1.num_kids)

Class Attributes 

    - Defined within the scope of the class and shared among all class instances 
    - Can be outside an instance method 

        class Marathon:
            race_distance = 42.195 (in km)
                - variable is shared across all class instances and remains the same 

        print(MarathonRunner.race_distance)  # Look in class namespace
            - calls the class name or the instance name to access the variable 
Instance Attributes 
    - can be unique to each class instance 

        class Marathon:
            def __init__(self):
                self.speed = 0

        runner1 = Marathon()
        runner1.speed = 7.5

        runner2 = Marathon()
        runner2.speed = 8.0 

        difference in instance attributes 
    - assigned using dot notation 

Class Constructors 

    __init__ can be customized with additional parameters
        - class RaceTime:
            def __init__(self, start_time, end_time, distance):
                self.start_hrs = start_hrs
                self.start_mins = start_mins
                self.end_hrs = end_hrs
                self.end_mins = end_mins
                self.distance = dist

        - when calling the class and creating an instance, the parameters must be passed 
    - Can have default values
        def __init__(self, start_time = 1, end_time = 12, distance = 30):


Class Interfaces
    - All methods, instance methods, attributes, etc that contribute to and make up a class 
    - Methods can be used internally within a class only and called from another method within that class 
        - prepend these with an underscore
            def _diff_time(self)

            - methods within a class may call _diff_time to perform an action within a method but diff_time itself may not be used externally
                - Example of abstraction 

Class Customization
    - defining how a class should behave for some common operations
    - implements instance methods with special method names
        - def __str__(self):
                can return an output statement 

Example : 

class Car:
    def __init__(self, make, model, year, miles, price):
        self.make = make
        self.model = model
        self.year = year
        self.miles = miles
        self.price = price

    def __str__(self):
        return f'{self.year} {self.make} {self.model}:\n\tMileage: {self.miles}\n\tSticker price: ${self.price}'

cars = []
cars.append(Car('Ford', 'Mustang', 2013, 25000, 37999))
cars.append(Car('Nissan', 'Xterra', 2004, 89500, 7500))
cars.append(Car('Nissan', 'Maxima', 2012, 25000, 15750))

for car in cars:
    print(car)
 
Operator Overloading

- Class customization can redefine the functionality of built-in operators like <, >=, +, -, and * when used with class instances
# lt = less than 
     def __lt__(self, other):
        if self.hours < other.hours:
            return True
        elif self.hours == other.hours:
            if self.minutes < other.minutes:
                return True
        return False
    - the Time class contains a definition for the __lt__ method, which overloads the < operator

- lt = <
- le = <=
- gt, ge 
- eq is == 
- ne is !=

- Compare if something is >, <, =, or != to another 

Overload Examples 
    class Duration:
    def __init__(self, hours, minutes):
        self.hours = hours
        self.minutes = minutes

    def __eq__(self, other):
        return (self.hours == other.hours) and (self.minutes == other.minutes)

workday = Duration(10, 30)
monday_time = Duration(10, 30)
tuesday_time = Duration(6, 0)

print(tuesday_time == workday)
print(monday_time == workday)

first print = False
second print = True

class CarRecord:
    def __init__(self):
        self.year_made = 0
        self.car_vin = ''

    # FIXME add __str__()

    """ Your solution goes here """
    def __str__(self):
        return f'Year: {self.year_made}, VIN: {self.car_vin}'

my_car = CarRecord()
my_car.year_made = int(input())
my_car.car_vin = input()

print(my_car)

More Overloading 

- numeric operators can be overloaded 
 - Subtraction:
            def __sub__(self, other):
        """ Calculate absolute distance between two times """
        if self > other:
            larger = self
            smaller = other
        else:
            larger = other
            smaller = self

        hrs = larger.hours - smaller.hours
        mins = larger.minutes - smaller.minutes
        if mins < 0:
            mins += 60
            hrs -=1

        # Check if times wrap to new day
        if hrs > 12:
            hrs = 24 - (hrs + 1)
            mins = 60 - mins

        # Return new Time24 instance 
        return Time24(hrs, mins)
    - Methods and descriptions
        __add__(self, other,)
        - Subtraction
        - mul - multiply 
        - truediv - divide
        - floordiv 
        - mod - modulus 
        - pow - exponent
        - and 
        - or 
        - abs(self) absolut value 
        - int(self) - conver to integer 
        - float(self)
 - isinstance()
    returns a True or False Boolean depending on whether a given variable matches a given type
    - stops the operator action 
- In a nutshell, operator overloading returns an operation function when an operation is used with a class intance 
    - so class nubmers:
        def __init__(self, value):
            self.value = value 

        def __add__(self, other):
            newvalue = self.value + other.value 

        - when an instance of the numbers class is called, if there is an adding operation, the __add__ function will be used 

Memory Allocatin & Garbage Collection

Memory 
- The process of an application requesting and being granted memory
- Python runtime handles memory allocation for the programmer
    - Python doesnt need to be compiled like C# or C++ 

Garbage 
- objects are deallocated automatically by the Python runtime
- reference count
    - an integer counter that represents how many variables reference an object
    - reference count is 0, that object is no longer referenced
        - garbage collector will deallocate objects with a reference count of 0
